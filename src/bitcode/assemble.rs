use super::code::*;
use super::label::*;
use super::bitcode_monad::*;

use crate::meta::*;
use crate::exec::*;

use std::collections::{HashMap};

///
/// Represents an assembler that is running
///
struct Assembler {
    /// Known values for the labels
    label_values: HashMap<Label, CellRef>,

    /// Bitcode that has been generated
    bitcode: Vec<BitCode>
}

impl Assembler {
    ///
    /// Creates a new assembler
    ///
    fn new() -> Assembler {
        Assembler {
            label_values:   HashMap::new(),
            bitcode:        vec![]
        }
    }

    ///
    /// Assembles a single monad using this assembler, returning the monad's value
    ///
    fn assemble(&mut self, monad: &BitCodeMonad) -> Result<CellRef, RuntimeError> {
        // Append the bitcode from this item
        match &monad.bitcode {
            BitCodeContent::Empty                   => {},
            BitCodeContent::Value(new_bitcode)      => self.bitcode.extend(new_bitcode.iter().cloned())
        }

        // Value depends on the contents of the monad
        match &monad.value {
            // A value passes the value directly to the map function, then evaluates the monad it returns
            BitCodeValue::Value(value)                      => Ok(value.clone()),

            // Allocates a new label, then evaluates the map function
            BitCodeValue::AllocLabel                        => unimplemented!(),

            // Looks up a label value (or prepares a second pass if the label has no value yet)
            BitCodeValue::LabelValue(value)                 => unimplemented!(),

            // Updates the value of a label, uses the value to map to the next monad
            BitCodeValue::SetLabelValue(label, value)       => unimplemented!(),

            // Map based on the current bit position
            BitCodeValue::BitPos                            => unimplemented!(),

            // Value is the result of applying the mapping function to the specified monad, and then trying again with the current monad
            BitCodeValue::FlatMap(monad, mappings)          => unimplemented!()
        }
    }
}

///
/// Assembles the bitcode generated by a bitcode monad, producing the final bitcode
///
pub fn assemble(monad: &BitCodeMonad) -> Result<Vec<BitCode>, RuntimeError> {
    let mut assembler = Assembler::new();

    assembler.assemble(monad)?;

    Ok(assembler.bitcode)
}
