use super::code::*;
use super::label::*;
use super::bitcode_monad::*;

use crate::meta::*;
use crate::exec::*;

use std::collections::{HashMap};

///
/// Represents an assembler that is running
///
struct Assembler {
    /// Known values for the labels
    label_values: HashMap<Label, CellRef>,

    /// Bitcode that has been generated
    bitcode: Vec<BitCode>,

    /// The current bitcode position
    bit_pos: u64,

    /// The next label ID to allocate for this assembler
    next_label_id: u64
}

impl Assembler {
    ///
    /// Creates a new assembler
    ///
    fn new() -> Assembler {
        Assembler {
            label_values:   HashMap::new(),
            bitcode:        vec![],
            bit_pos:        0,
            next_label_id:  0
        }
    }

    ///
    /// Retrieves the Label attached to a label cell
    ///
    fn get_label(&self, label_cell: &CellRef) -> Result<Label, RuntimeError> {
        match &**label_cell {
            // Value should be a label cell generated by AllocLabel
            SafasCell::Any(maybe_label) => {
                if let Some(label) = maybe_label.downcast_ref::<Label>() {
                    Ok(*label)
                } else {
                    Err(RuntimeError::NotALabel(label_cell.clone()))
                }
            },

            // Other types are not a label
            _ => Err(RuntimeError::NotALabel(label_cell.clone()))
        }
    }

    ///
    /// Reads the value of a label contained within a cell
    ///
    fn get_label_value(&mut self, label_cell: &CellRef) -> Result<CellRef, RuntimeError> {
        // Get the label from the cell
        let label = self.get_label(label_cell)?;

        // Read the label value if it's known (labels have the 'nil' value when they're not known yet, and we do further passes)
        if let Some(label_value) = self.label_values.get(&label) {
            // Already know the value of this label
            Ok(label_value.clone())
        } else {
            // Will need more passes to evaluate this label - TODO, flag this up
            Ok(NIL.clone())
        }
    }

    ///
    /// Sets the value of a label to a new value
    ///
    fn set_label_value(&mut self, label_cell: &CellRef, value: CellRef) -> Result<CellRef, RuntimeError> {
        // Get the label from the cell
        let label = self.get_label(label_cell)?;

        // Set/update the label value (TODO: when updating, indicate that another pass is needed if the value is different to before)
        self.label_values.insert(label, value.clone());

        // Result is the value
        Ok(value)
    }

    ///
    /// Appends bitcode to this element 
    ///
    fn append_bitcode(&mut self, bitcode: &BitCodeContent) {
        match bitcode {
            BitCodeContent::Empty           => {},
            BitCodeContent::Value(bitcode)  => {
                self.bit_pos = BitCode::position_after(self.bit_pos, bitcode.iter());
                self.bitcode.extend(bitcode.iter().cloned());
            }
        }
    }

    ///
    /// Assembles a single monad using this assembler, returning the monad's value
    ///
    fn assemble(&mut self, monad: &BitCodeMonad) -> Result<CellRef, RuntimeError> {
        // Append the initial bitcode
        self.append_bitcode(&monad.bitcode);

        // Work out the value depending on the content of the monad
        let result = match &monad.value {
            // Simple value
            BitCodeValue::Value(value)                      => Ok(value.clone()),

            // Allocates a new label
            BitCodeValue::AllocLabel                        => {
                let label_id        = self.next_label_id;
                self.next_label_id  += 1;

                Ok(SafasCell::Any(Box::new(Label::with_id(label_id))).into())
            },

            // Looks up a label value (or prepares a second pass if the label has no value yet)
            BitCodeValue::LabelValue(value)                 => self.get_label_value(value),

            // Updates the value of a label, uses the value to map to the next monad
            BitCodeValue::SetLabelValue(label, value)       => self.set_label_value(label, value.clone()),

            // Map based on the current bit position
            BitCodeValue::BitPos                            => Ok(SafasCell::Number(SafasNumber::BitNumber(64, self.bit_pos as u128)).into()),

            // Value is the result of applying the mapping function to the specified monad, and then trying again with the current monad
            BitCodeValue::FlatMap(monad, mappings)          => {
                // The initial value comes from the initial monad
                let mut value       = self.assemble(monad)?;

                // Evaluate each mapping in turn
                for mapping in mappings.iter() {
                    let next_monad  = mapping(value)?;
                    value           = self.assemble(&next_monad)?;
                }

                // Final value from the final monad
                Ok(value)
            }
        };

        // Append the following bitcode if there is any
        self.append_bitcode(&monad.following_bitcode);

        // Return the value we generated
        result
    }
}

///
/// Assembles the bitcode generated by a bitcode monad, producing the final bitcode
///
pub fn assemble(monad: &BitCodeMonad) -> Result<(CellRef, Vec<BitCode>), RuntimeError> {
    // Create an assembler, and assemble this monad
    let mut assembler   = Assembler::new();
    let value           = assembler.assemble(monad)?;

    Ok((value, assembler.bitcode))
}

#[cfg(test)]
mod test {
    use crate::interactive::*;
    use crate::bitcode::*;

    #[test]
    fn return_value_from_assembler() {
        let result          = eval("((fun () (d 0u64) 1u64))").unwrap();
        let monad           = BitCodeMonad::from_cell(&result).unwrap();

        let (val, _bitcode) = assemble(&monad).unwrap();
        println!("{}", val.to_string());

        assert!(val.to_string() == "1u64".to_string());
    }
}
